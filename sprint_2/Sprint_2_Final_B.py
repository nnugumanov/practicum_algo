import operator

"""
-- ПРИНЦИП РАБОТЫ --
Последовательно, поэлементно обрабатываем строку. Элемент - последовательность символов выделенная пробелами.
Если элемент является числом - кладем в стек.
Если же элемент является арифметической операцией - достаем два элемента из стека и совершаем операцию.
Полученный результат кладем в стек.
После завершения обработки входных данных - извлекаем элемент из стека и выводим его.

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Из описания обратной польской нотации следует что арифметическая операция должна выполняться на предшествующих двух операндах, результат является в свою очередь операндом, использующемся в следующих операциях.

Стек (LIFO) идеально подходит, т.к позволит работать именно с последними операндами.

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
 Амортизированная сложность добавления/удаления элемента в python list = O(1).
 Можно было заранее проинициализировать list с известным максимальным допустимым количеством элементов, тогда бы и неамортизированная сложность была равна O(1).

 Временная сложность программы - O(n). Время выполнения операций даже в худшем случае (для каждого операнда в строке есть операция, например
 "1 1 + 1 + 1 + 1 + 1") линейно зависит от количества операций и чисел на входе.
 
 # r - количество чисел
 # m - количество операций.
 # для каждой операции нужно выполнить три действия со стеком.
 # Получаем сложность O(r + 3m). Емнип, в оценке сложности, это эквивалентно O(n)
  
-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
Пространственная сложность алгоритма - O(n + 2^(log(n+1))) где n - количество элементов в строке. 

Пример: допустим мы уже храним в текущем списке 512 операндов и нам нужно записать еще один элемент, 513й.
     python создаст новый массив, размером 2^(log(512)+1) = 1024 элемента.
     После расширения, старый массив деаллоцируется, но мы же считаем худшую пространственную сложность.
     Поэтому принимаем ее как O(n + 2^(log(n+1)))
"""


class Stack:
    def __init__(self):
        self._stack = []

    def pop(self) -> int:
        return self._stack.pop()

    def push(self, op: int) -> None:
        self._stack.append(op)


operations = {
    '+': operator.add,
    '-': operator.sub,
    '*': operator.mul,
    '/': operator.floordiv,
}


def main():
    items = input().split()
    stack = Stack()

    for item in items:
        if item.isnumeric() or \
                (item.startswith("-") and item[1:].isnumeric()):
            stack.push(int(item))
        elif item in operations.keys():
            try:
                b = stack.pop()
                a = stack.pop()
                res = operations[item](a, b)
                stack.push(res)
            except IndexError:
                print("Missing operand. Terminate program")
                exit(1)
    print(stack.pop())


if __name__ == "__main__":
    main()
