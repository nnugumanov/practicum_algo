# посылка 75972281
"""
-- ПРИНЦИП РАБОТЫ --
   Решим задачу алгоритмом Вагнера-Фишера.

   Создадим матрицу D размерности N*M где N - длина второго слова, M - длина первого слова
   Первую строку и первую колонку матрицы инициализируем номерами в строке и в колонке соответственно.

   Заполним ячейки матрицы по принципу:
    Если буквы с одинаковой позицией совпадают, то "расстояние" копируем из предыдущей по диагонали ячейки. Т.е для
    совпадающей i-й буквы, расстояние не изменилось и равно расстоянию вычисленному для i-1 буквы.
    Иначе расстояние высчитывается как минимум из тройки соседних (сверху, слева и сверху-слева) ячеек увеличенных на
    единицу.
   Итоговое решение будет находится в ячейке D(len(word1),len(word2)

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
    - расстояние между двумя пустыми строками равно нулю
    - расстояние между пустой и непустой строками равно длине непустой строки
    - для непустых строк нужно рассмотреть 4 кейса: cовпадение символов, удаление, вставку и замену символа
      - пусть cтрока S оканчивается на символ 'a', которого нет в строке T. Тогда мы удаляем символ 'a', превращаем
      строку S в T (на что потребовалось D(i, j-1) операций). Значит всего потребовалось  D(i, j-1) + 1 операция.
      - аналогично с добавлением последнего символа, превращая S в T: итого нужно D(i-1, j) + 1 операций.
      - для превращения S в T потребовалось заменить последний символ: в этом случае нужно  D(i-1, j-1) + 1 операций.
      - если i-ые символы совпадают, расстояние не меняется и остается равным D(i-1, j-1)

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
    O(N*M) где N и M - длины слов.

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
    O(N*M) где N и M - длины слов.

    Можно было бы уменьшить затраты, если использовать матрицу высотой в 2 строки, но адресация будет сложнее.
"""


def main():
    s = input()
    t = input()
    D = [[0 for i in range(len(t) + 1)] for j in range(len(s) + 1)]

    for i in range(len(s) + 1):
        D[i][0] = i
    for i in range(len(t) + 1):
        D[0][i] = i

    for i in range(1, len(s) + 1):
        for j in range(1, len(t) + 1):
            if s[i - 1] == t[j - 1]:
                D[i][j] = D[i - 1][j - 1]
            else:
                _ins = D[i][j - 1] + 1
                _del = D[i - 1][j] + 1
                _rep = D[i - 1][j - 1] + 1
                D[i][j] = min(_ins, _del, _rep)

    print(D[len(s)][len(t)])

if __name__ == "__main__":
    main()
